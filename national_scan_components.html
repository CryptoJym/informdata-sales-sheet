<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>InformData National Criminal Repository Coverage (Oct 3, 2025)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="styles/tokens.css" />
</head>
<body class="page-product">
  <div data-include="components/header.html"></div>
  <main class="page" id="main-content">
    <section>
      <h1>National Criminal Repository Coverage</h1>
      <p class="lead">Latest dataset received <strong>October 3, 2025</strong>, detailing every database included in InformData’s national criminal search (NatCrim). Use this to back up the “1B+ records” claim and to confirm state-by-state breadth.</p>
      <div class="stat-grid" id="stats"></div>
      <div class="download-links">
        <a href="content/pricing/natcrim_sources_2025-10-03.csv" download>NatCrim sources CSV <span>(canonical schema)</span></a>
        <a href="content/pricing/natcrim_sources_2025-10-03.parquet" download>NatCrim sources Parquet <span>(analytics ready)</span></a>
        <a href="reports/natcrim_coverage_gaps_2025-10-03.md" download>QA report <span>(gaps &amp; stale checks)</span></a>
      </div>
    </section>

    <section>
      <h2>State totals (top performers)</h2>
      <div class="chart-container">
        <canvas id="stateChart" aria-label="State record totals"></canvas>
      </div>
    </section>

    <section>
      <h2>Coverage domains</h2>
      <p class="table-note">Domains normalize source scope (statewide, DOC, warrant, etc.). Click a bucket to see leading states by record volume. Full rollup lives in <code>content/pricing/natcrim_scope_summary_2025-10-03.csv</code>.</p>
      <div class="filters" id="domainFilters"></div>
      <div class="stat-grid" id="domainStats"></div>
      <div class="chart-container small">
        <div class="table-responsive">
      <table id="domain-table">
        <caption>Source Directory</caption> <caption>Coverage by Domain</caption><thead>
            <tr>
              <th>State</th>
              <th>Sources</th>
              <th>Total records</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      </div>
    </section>

    <section>
      <h2>Sample sources by state</h2>
      <p>Scroll or filter to find specific states or record types. dataset: <code>content/pricing/natcrim_sources_2025-10-03.csv</code></p>
      <div class="filters" id="recordFilters"></div>
      <div class="table-responsive">
      <table id="source-table">
        <thead>
          <tr>
            <th>State</th>
            <th>Record type</th>
            <th>Source name</th>
            <th>Coverage scope</th>
            <th>Court level</th>
            <th>Last refresh</th>
            <th>Record count</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      </div>
    </section>
  </main>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
  <div data-include="components/footer.html"></div>
  <script src="components/include.js" defer></script>
  <script>
    function parseCSV(text) {
      if (!text) return [];
      const lines = text.trim().split(/\r?\n/);
      if (!lines.length) return [];
      const headers = lines.shift().split(',').map(h => h.trim());
      return lines.map(line => {
        const values = [];
        let current = '';
        let inQuotes = false;
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            values.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        values.push(current.trim());
        const obj = {};
        headers.forEach((key, idx) => {
          const raw = values[idx] ?? '';
          obj[key] = raw.replace(/^"|"$/g, '');
        });
        return obj;
      });
    }

    function formatNumber(value) {
      return Number(value || 0).toLocaleString();
    }

    async function loadData() {
      const [stateTotalsResp, sourceResp, scopeResp] = await Promise.all([
        fetch('content/pricing/natcrim_state_totals_2025-10-03.csv'),
        fetch('content/pricing/natcrim_sources_2025-10-03.csv'),
        fetch('content/pricing/natcrim_scope_summary_2025-10-03.csv')
      ]);

      const stateTotalsRaw = parseCSV(await stateTotalsResp.text());
      const sourcesRaw = parseCSV(await sourceResp.text());
      // Exclude known non-jurisdictional aggregation row that inflates listings by 1
      const filteredRaw = sourcesRaw.filter(r => (r.source_name||'').toLowerCase() !== 'every politician');
      const scopeSummaryRaw = parseCSV(await scopeResp.text());

      const stateTotals = stateTotalsRaw
        .filter(row => row.standardized_state)
        .map(row => ({
          code: row.standardized_state,
          stateName: row.state_name,
          records: Number(row.record_count || 0)
        }));

      const sources = filteredRaw
        .filter(row => row.standardized_state)
        .map(row => ({
          code: row.standardized_state,
          stateName: row.state_name,
          recordType: row.record_type,
          sourceName: row.source_name,
          coverageScope: row.coverage_scope,
          courtLevel: row.court_level,
          refreshDate: row.refresh_date,
          recordCount: Number(row.record_count || 0)
        }));

      const scopeSummary = scopeSummaryRaw
        .filter(row => row.coverage_domain)
        .map(row => ({
          code: row.standardized_state,
          stateName: row.state_name,
          domain: row.coverage_domain,
          sourceCount: Number(row.source_count || 0),
          totalRecords: Number(row.total_records || 0)
        }));

      const overallRecords = stateTotals.reduce((sum, row) => sum + row.records, 0);
      const totalListings = sources.length; // statewide + county rows (filtered)
      const uniqueDatabases = new Set(sources.map(r => r.sourceName)).size; // distinct source names
      const statesCovered = new Set(sources.map(row => row.code)).size;

      const statsEl = document.getElementById('stats');
      statsEl.innerHTML = `
        <div class="stat-card"><strong>${(overallRecords / 1_000_000_000).toFixed(2)}B</strong><span>Total records indexed</span></div>
        <div class="stat-card"><strong>${formatNumber(uniqueDatabases)}</strong><span>Distinct databases (unique sources)</span></div>
        <div class="stat-card"><strong>${formatNumber(totalListings)}</strong><span>Dataset listings (incl. county rows)</span></div>
        <div class="stat-card"><strong>${statesCovered}</strong><span>States &amp; territories</span></div>
      `;

      // State totals chart
      const topStates = [...stateTotals].sort((a, b) => b.records - a.records).slice(0, 15);
      const ctx = document.getElementById('stateChart');
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: topStates.map(row => `${row.code}`),
          datasets: [{
            label: 'Total Records',
            data: topStates.map(row => row.records),
            backgroundColor: 'rgba(37, 99, 235, 0.65)'
          }]
        },
        options: {
          responsive: true,
          plugins: { legend: { display: false } },
          scales: {
            y: { beginAtZero: true, ticks: { callback: value => formatNumber(value) } }
          }
        }
      });

      // Coverage domains summary
      const domainTotalsMap = new Map();
      scopeSummary.forEach(row => {
        const key = row.domain;
        if (!domainTotalsMap.has(key)) {
          domainTotalsMap.set(key, { domain: key, sources: 0, records: 0 });
        }
        const entry = domainTotalsMap.get(key);
        entry.sources += row.sourceCount;
        entry.records += row.totalRecords;
      });
      const domainTotals = Array.from(domainTotalsMap.values()).sort((a, b) => b.records - a.records);

      const domainFiltersEl = document.getElementById('domainFilters');
      const domainStatsEl = document.getElementById('domainStats');
      const domainTableBody = document.querySelector('#domain-table tbody');

      function renderDomainStats() {
        domainStatsEl.innerHTML = domainTotals.map(item => `
          <div class="stat-card">
            <strong>${formatNumber(item.records)}</strong>
            <span>${item.domain.replace(/_/g, ' ')} records</span>
            <span class="block mt-1 text-xs">${formatNumber(item.sources)} sources</span>
          </div>
        `).join('');
      }

      let activeDomain = domainTotals.length ? domainTotals[0].domain : null;

      function renderDomainFilters() {
        const domains = domainTotals.map(item => item.domain);
        domainFiltersEl.innerHTML = domains.map(domain => `
          <button type="button" class="chip ${domain === activeDomain ? 'active' : ''}" data-domain="${domain}">
            ${domain.replace(/_/g, ' ')}
          </button>
        `).join('');
        domainFiltersEl.querySelectorAll('button').forEach(btn => {
          btn.addEventListener('click', () => {
            activeDomain = btn.dataset.domain;
            renderDomainFilters();
            renderDomainTable();
          });
        });
      }

      function renderDomainTable() {
        const rows = scopeSummary
          .filter(row => !activeDomain || row.domain === activeDomain)
          .sort((a, b) => b.totalRecords - a.totalRecords)
          .slice(0, 20);
        domainTableBody.innerHTML = rows.map(row => `
          <tr>
            <td>${row.code} (${row.stateName})</td>
            <td>${formatNumber(row.sourceCount)}</td>
            <td>${formatNumber(row.totalRecords)}</td>
          </tr>
        `).join('');
      }

      renderDomainStats();
      renderDomainFilters();
      renderDomainTable();

      // Record type filters for source table
      const recordFiltersEl = document.getElementById('recordFilters');
      const sourceTableBody = document.querySelector('#source-table tbody');
      const recordTypes = ['ALL', ...Array.from(new Set(sources.map(row => row.recordType))).sort()];
      let activeRecordType = 'ALL';

      function renderRecordFilters() {
        recordFiltersEl.innerHTML = recordTypes.map(type => `
          <button type="button" class="chip ${type === activeRecordType ? 'active' : ''}" data-type="${type}">${type.replace(/_/g, ' ')}</button>
        `).join('');
        recordFiltersEl.querySelectorAll('button').forEach(btn => {
          btn.addEventListener('click', () => {
            activeRecordType = btn.dataset.type;
            renderRecordFilters();
            renderSourceTable();
          });
        });
      }

      function renderSourceTable() {
        const filtered = sources.filter(row => activeRecordType === 'ALL' || row.recordType === activeRecordType);
        const rows = filtered.slice(0, 500);
        sourceTableBody.innerHTML = rows.map(row => `
          <tr>
            <td>${row.code}</td>
            <td>${row.recordType}</td>
            <td>${row.sourceName}</td>
            <td>${row.coverageScope}</td>
            <td>${row.courtLevel}</td>
            <td>${row.refreshDate}</td>
            <td>${formatNumber(row.recordCount)}</td>
          </tr>
        `).join('');
      }

      renderRecordFilters();
      renderSourceTable();
    }

    loadData();
  </script>
</body>
</html>
